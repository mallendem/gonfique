package coder

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"os"
	"regexp"
	"slices"
	"strings"

	"github.com/ufukty/gonfique/cmd/gonfique/commands/version"
	"github.com/ufukty/gonfique/internal/files/coder/sort"
	"github.com/ufukty/gonfique/internal/files/config"
	"github.com/ufukty/gonfique/internal/files/config/meta"
	"github.com/ufukty/gonfique/internal/files/input"
	"github.com/ufukty/gonfique/internal/namings"
	"golang.org/x/exp/maps"
)

type Coder struct {
	ti *ast.Ident

	Meta     meta.Meta
	Encoding input.Encoding

	Config ast.Expr

	Imports     []string
	Named, Auto map[config.Typename]*ast.GenDecl

	Accessors            map[config.Typename][]*ast.FuncDecl
	Iterators            map[config.Typename]*ast.FuncDecl
	ParentRefAssignments []ast.Stmt
}

func quotes(s string) string {
	return fmt.Sprintf("%q", s)
}

func uniq[K comparable](ss []K) []K {
	m := make(map[K]any, len(ss))
	for _, s := range ss {
		m[s] = nil
	}
	return maps.Keys(m)
}

func (c Coder) addImports(dst *ast.File) {
	imports := slices.Clone(c.Imports)

	imports = append(imports, "fmt", "os") // ReadConfig
	switch c.Encoding {
	case input.Yaml:
		imports = append(imports, "gopkg.in/yaml.v3")
	case input.Json:
		imports = append(imports, "encoding/json")
	}
	if len(c.Iterators) > 0 {
		imports = append(imports, "iter")
	}

	slices.Sort(imports)
	imports = uniq(imports)

	specs := []ast.Spec{}
	for _, imp := range imports {
		specs = append(specs, &ast.ImportSpec{
			Path: &ast.BasicLit{Kind: token.STRING, Value: quotes(imp)},
		})
	}
	sort.Imports(specs)

	dst.Decls = append(dst.Decls, &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	})
}

func concat[K comparable, V any](ms ...map[K]V) map[K]V {
	t := 0
	for _, m := range ms {
		t += len(m)
	}
	m2 := make(map[K]V, t)
	for _, m := range ms {
		for k, v := range m {
			m2[k] = v
		}
	}
	return m2
}

func mki[K comparable, V any](m map[K]V, k K) {
	_, ok := m[k]
	if !ok {
		m[k] = *new(V)
	}
}

func (c Coder) createGenDecls(dst *ast.File) {
	decls := []ast.Decl{}
	if c.Auto != nil {
		for _, n := range c.Auto {
			decls = append(decls, n)
		}
	}
	if c.Named != nil {
		for _, n := range c.Named {
			decls = append(decls, n)
		}
	}
	if c.Config != nil {
		decls = append(decls, &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{&ast.TypeSpec{
				Name: ast.NewIdent(c.Meta.Type),
				Type: c.Config,
			}},
		})
	}
	decls = sort.Decls(decls)

	ds := concat(c.Auto, c.Named)
	methods := map[*ast.GenDecl][]ast.Decl{}
	if c.Iterators != nil {
		for tn, iterator := range c.Iterators {
			if gd, ok := ds[tn]; ok {
				mki(methods, gd)
				methods[gd] = append(methods[gd], iterator)
			}
		}
	}
	if c.Accessors != nil {
		for tn, accessors := range c.Accessors {
			if gd, ok := ds[tn]; ok {
				mki(methods, gd)
				for _, a := range accessors {
					methods[gd] = append(methods[gd], a)
				}
			}
		}
	}

	l := len(decls)
	for i, e := 0, 0; i < l; i++ {
		d := decls[i+e]
		if gd, ok := d.(*ast.GenDecl); ok {
			if ms, ok := methods[gd]; ok {
				decls = slices.Insert(decls, i+e+1, ms...)
				e += len(ms)
			}
		}
	}

	dst.Decls = append(dst.Decls, decls...)
}

var typedecls = regexp.MustCompile(`(?m)$(\n(?://.*\n)*type)`)
var funcdecls = regexp.MustCompile(`(?m)$(\n(?://.*\n)*func)`)
var imports = regexp.MustCompile(`(?m)import \(((?:\s+"[\w]+(?:/[\w.]+)*"\n)*)((?:\s+"[\w.]+(?:/[\w.]+)*"\n)*)\)`)

func post(s string) string {
	s = fmt.Sprintf("// Code generated by gonfique %s. DO NOT EDIT.\n\n%s", version.Version, s)
	s = typedecls.ReplaceAllString(s, "\n$1")
	s = funcdecls.ReplaceAllString(s, "\n$1")
	s = imports.ReplaceAllString(s, "import ($1\n$2)") // split packages starts with domains
	// 3 lines are for iterators
	s = strings.ReplaceAll(s, "{\"", "{\n\"")
	s = strings.ReplaceAll(s, ", \"", ",\n\"")
	s = strings.ReplaceAll(s, "}\n\t\tfor", ",\n}\n\t\tfor")
	return s
}

func (c Coder) Write(dst string) error {
	c.ti = ast.NewIdent(namings.Initial(c.Meta.Type))

	f := &ast.File{
		Name:  ast.NewIdent(c.Meta.Package),
		Decls: []ast.Decl{},
	}
	c.addImports(f)
	c.createGenDecls(f)

	c.addParentRefAssignmentsFunction(f)
	if err := c.addReaderFunction(f); err != nil {
		return fmt.Errorf("reader: %w", err)
	}

	b := bytes.NewBufferString("")
	err := printer.Fprint(b, token.NewFileSet(), f)
	if err != nil {
		return fmt.Errorf("write: %w", err)
	}

	p := post(b.String())
	fs, err := format.Source([]byte(p))
	if err != nil {
		return fmt.Errorf("format: %w", err)
	}

	o, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("create: %w", err)
	}
	defer o.Close()
	fmt.Fprintf(o, "%s", fs)

	return nil
}
