package directives

import (
	"fmt"
	"go/ast"
	"slices"

	"github.com/ufukty/gonfique/internal/bundle"
	"github.com/ufukty/gonfique/internal/compares"
	"github.com/ufukty/gonfique/internal/datas"
	"github.com/ufukty/gonfique/internal/directives/accessors"
	"github.com/ufukty/gonfique/internal/models"
	"github.com/ufukty/gonfique/internal/namings"
	"golang.org/x/exp/maps"
)

func compareMergedTypenameUsers(b *bundle.Bundle) error {
	for tn, kps := range b.TypenameUsers {
		for i := 1; i < len(kps); i++ {
			if !compares.Compare(b.TypeExprs[kps[0]], b.TypeExprs[kps[i]]) {
				return fmt.Errorf("%q and %q doesn't share the same schema, but required to share same type %q", kps[0], kps[i], tn)
			}
		}
	}
	return nil
}

func typenames(b *bundle.Bundle) error {
	// collect
	if err := accessors.TypenameRequirements(b); err != nil {
		return fmt.Errorf("checking requirements for accessors: %w", err)
	}
	if err := parent(b); err != nil {
		return fmt.Errorf("checking requirements for parent refs: %w", err)
	}

	b.NeededToBeReferred = datas.Uniq(b.NeededToBeReferred)
	b.NeededToBeDeclared = datas.Uniq(b.NeededToBeDeclared)

	autogeneratedTypenames := namings.GenerateTypenames(maps.Values(b.Keypaths))
	providedTypenames := map[models.FlattenKeypath]models.TypeName{}
	for wckp, dirs := range *b.Df {
		if dirs.Named != "" {
			kps := b.Expansions[wckp]
			for _, kp := range kps {
				providedTypenames[kp] = dirs.Named
			}
		}
	}

	// election
	for _, kp := range slices.Concat(b.NeededToBeReferred, b.NeededToBeDeclared) {
		tn, ok := providedTypenames[kp]
		if ok {
			b.ElectedTypenames[kp] = tn
			continue
		}
		id, ok := b.TypeExprs[kp].(*ast.Ident)
		if ok {
			b.ElectedTypenames[kp] = models.TypeName(id.Name)
			continue
		}
		if autogen, ok := autogeneratedTypenames[kp]; ok {
			b.ElectedTypenames[kp] = autogen
			continue
		}
		return fmt.Errorf("can't elect a typename for keypath: %s", kp)
	}
	b.TypenameUsers = datas.Revmap(b.ElectedTypenames)

	// declare referred types except string, int, etc.
	for _, kp := range b.NeededToBeReferred {
		if _, ok := b.TypeExprs[kp].(*ast.Ident); !ok {
			b.NeededToBeDeclared = append(b.NeededToBeDeclared, kp)
		}
	}

	b.NeededToBeReferred = datas.Uniq(b.NeededToBeReferred)
	b.NeededToBeDeclared = datas.Uniq(b.NeededToBeDeclared)

	return nil
}
